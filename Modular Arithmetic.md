# মডুলার পাটিগণিত
```
মডুলার পাটিগণিত গণিতের একটি শাখা যেখানে পূর্ণসংখ্যা এবং নির্দিষ্ট একটি সংখ্যার পর সংখ্যাগুলো পুনরায় ফিরে আসা নিয়ে আলোচনা করা হয়। এই নির্দিষ্ট সংখ্যাকে বলা হয় মডুলাস।

১২-ঘণ্টা ঘড়িতে মডুলার পাটিগণিতের জন্য একটি ভাল উদাহরণ। ধরা যাক 12’টা ঘড়ি মানে 0। তারপর ঘড়ি নিম্নলিখিত মানগুলি দেখায়, 0,1,2,3,4,5,6,7,8,9,10,11,0,1,2,3.....
প্রতিবার ঘড়ির কাঁটা যখন 12টায় আঘাত করে, তখন এটি প্রায় 0-এর কাছাকাছি চলে যায়। যেহেতু ঘড়ির কাঁটা 12 এর কাছাকাছি থাকে, তাই আমরা বলি যে 12 হল মডুলাস।

মডুলো অপারেশন চিহ্ন % । A % B = C প্রকাশের অর্থ হল যখন আমরা A কে B দিয়ে ভাগ করি তখন আমরা অবশিষ্ট C পাই।

উদাহরণ স্বরূপ:
5 % 3 = 2
15 % 5 = 0
24 % 30 = 24
30 % 24 = 6
4 % 4 = 0
```

মডুলার পাটিগণিতের চারটি বৈশিষ্ট্য রয়েছে যা আমাদের শিখতে হবে।

```
Addition

5 ≡ 10 (mod 5) // 0 ≡ 0
2 ≡ 7 (mod 5) // 2 ≡ 2
4 ≡ 10 (mod 3) // 1 ≡ 1
"A ≡ B (mod M) মানে হল A এবং B উভয়ের অবশিষ্টাংশ একই থাকে যখন A এবং B উভয়কে  M দ্বারা ভাগ করা হয়"

if, a ≡ b (mod m) and c ≡ d (mod m) then, a+c ≡ b+d (mod m)

For example,
5 + 2 ≡ 10 + 7 mod 5
7 ≡ 17 mod 5
2 = 2

(a1+a2+a3…+an) % m
=> ((a1 % m) + (a2 % m) +...(an % m)) % m

For example, 
(13+24+44) % 3
= (13%3+ 24%3 + 44%3) % 3
= (1+0+2) % 3 
= 3 % 3
= 0

Subtraction

if, a ≡ b (mod m) and c ≡ d (mod m) then, a-c ≡ b-d (mod m)

উদাহরণস্বরূপ,
5 - 2 ≡ 10 - 7 mod 5
3 ≡ 3 mod 5
3 = 3

(a1-a2-a3…-an) % m
=> ((a1 % m) + (a2 % m) +...(an % m)) % m

উদাহরণস্বরূপ, 
(13-24-44) % 3
= (13%3 - 24%3 - 44%3) % 3
= (1-0-2) % 3 
= -1 % 3
= 2     [ -1 - (-3) = -1 + 3 = 2 [3 এর সব থেকে বড় মাল্টিপল, যেটা -1 এর থেকে ছোট = -3]


Multiplication

if, a ≡ b (mod m) and c ≡ d (mod m) then, a x c ≡ b x d (mod m)

উদাহরণস্বরূপ,
5 * 2 ≡ 10 * 7 mod 5
10 ≡ 70 mod 5
0 = 0

উদাহরণস্বরূপ, 
(14×25×44) % 3
= (14%3 × 25%3 × 44%3) % 3
= (2×1×2) % 3 
= 4 % 3
= 1 % 3
= 1

Division

মডুলার বিভাগ উপরের তিনটির মতো কাজ করে না। এটি, a/b not ≡ (a % m) / (b % m) (mod m)

উদাহরণস্বরূপ, (6/3) % 3 = 2 হওয়া উচিত। কিন্তু উপরের সূত্রটি ব্যবহার করে আমরা (0/0) % 3 পাই।

```

### ১০০টি বই আছে,আমরা কয়ভাবে বইগুলো সাজাতে পারবো ?

```
১০০! (১০০ ফ্যাক্টরিয়াল) ভাবে সাজাতে পারবো। ১০০! ১৫৮ ডিজিটের বিশাল একটি সংখ্যা। অর্থাত ১০০! বের করে ৯৭ দিয়ে ভাগ করে ভাগশেষটা বের করাই সমস্যা।

১০০! এর মান বের করতে পারবো না, ৬৪ বিট আনসাইনড ইন্টিজার দিয়েও, এরা ২^৬৪ − ১ পর্যন্ত সংখ্যা নিয়ে কাজ করতে পারে, তাই ওভারফ্লো হবে। কিন্তু আমরা জানি 
আমাদের উত্তর কখনোই 97 এর বড় হবেনা কারণ কোনো সংখ্যাকে m দিয়ে mod করা হলে সংখ্যাটি m এর থেকে বড় হতে পারবেনা।

```
```c++
আমরা এ ধরণের সমস্যা সমাধান করতে সাহায্য নিবো দুটি সুত্রের :

1. (a + b) mod n = [(a mod n) + (b mod n)] mod n.
2. a*b mod n = [(a mod n)(b mod n)] mod n.

উপরের সমস্যাটিতে ২য় সুত্রটি লাগবে। আমাদের বের করা দরকার ১০০!%৯৭ . অর্থাত: (১০০ x ৯৯ x ৯৮ x ....... x১)%৯৭
```
``` c++
 #include<bits/stdc++.h>
 using namespace std;
 
 int main() {
    int fact=1;
    for(int i=1;i<=100;i++){
      fact=((fact%97)*(i%97))%97;
    }
    printf("%d\n",fact);
 }   
```
    
```c++
এটার আউটপুট আসবে 0। অর্থাত ১০০! % ৯৭ = 0।

গুণ করার সময় ২য় সুত্রের মত করে mod করতে থাকবে,তাহলে কোনো সময়ই overflow ঘটবেনা কারণ mod করলে প্রতি স্টেপে সংখ্যাটি ছোটো হয়ে যাচ্ছে।
```

### প্রমাণ : ১ম সুত্রটির প্রমাণ

![image](https://user-images.githubusercontent.com/59710234/154542900-1653aeee-d9d1-4843-b57f-83844c1ac1b1.png)

```
এখানে,

X%5 = c1
Y%5 = c2
X = 5*n1 + c1
Y = 5*n2 + c2

[যেখানে n1 আর n2 দুটি ইন্টিজার।]

এখানে 5n1 + 5n2 অবশ্যই 5 এর মাল্টিপল,তাই আমরা লিখতে পারি,
5n1 + 5n2 = 5N [ N = n1 + n2 ] এবং
c1 + c2 = C

তাহলে (১) থেকে পাচ্ছি: (5N + C) % 5

এখন পরিস্কার বোঝা যাচ্ছে যে উত্তর হলো C%5 । C কে আবার mod করতে হলো কারণ c1+c2 এর মান 5 এর থেকে বড় হতেই পারে।
```
![image](https://user-images.githubusercontent.com/59710234/154545620-482ea93e-34d1-4e02-aabc-a4403eb63b9c.png)

```c++
তাহলে ২ কে লিখতে পারি: (c1 + c2)%5 = C%5
```
```
NOTE :

X = 13
n1 = X/5 = 13/5 = 2
c1 = X%5 = 13%5 = 3
so, X = 5*n1 + c1 = 5*2 + 3 = 13

Y = 22
n2 = Y/5 = 22/5 = 4
c2 = Y%5 = 22%5 = 2
so, Y = 5*n2 + c2 = 5*2 + 3 = 13

5n1 + 5n2 = 5*2 + 5*4 = 10 + 20 = 30 [5 er মাল্টিপল 30 ]
N = n1 + n2 = 2 + 4 = 6  সুতরাং, 5*N = 5*6 = 30
so, 5n1 + 5n2 = 5N

c1 + c2 এর মান 5 এর থেকে বড় হতেই পার । c1 = 4 < 5  and c2 = 2 < 5  সুতরাং, c1 + c2 = 6 > 5

(5N + C) % 5;
5N % 5 = 0
C % 5 হল উত্তর ।
```
```
তাহলে ১ম সুত্রটি প্রমাণিত হলো। তারমান যোগ করে mod করা আর আগে mod করে তারপর যোগ করে আবার mod করা একই কথা। সুবিধা হলে সংখ্যাটি কোনো স্টেপেই বেশি বড় হতে পারেনা। গুণের ক্ষেত্রেই একই সুত্র প্রযোজ্য।
```

### নেগেটিভ সংখ্যার mod নিয়ে একটু আলাদা ভাবে কাজ করতে হয়।

```
x % m = p
23%5 = 20

ভাগশেষের যে সংজ্ঞা :

m এর সব থেকে বড় মাল্টিপল, যেটা x এর থেকে ছোট (যেমন: 23%5 এর ক্ষেত্রে ৫ × ৪ = ২০ হলো ৫ এর সবথেকে বড় মাল্টিপল যেটা ২৩ এর থেকে ছোট) ; সেই সংখ্যাটিকে x থেকে বিয়োগ করলে যে সংখ্যাটি পাওয়া যায় সেটাই p । ( যেমন: 23%5 = 23 − 20 = 3 )
```
```c++
−17%5 মনে হয়ে  এর মান -২ | কিন্তু  কিন্তু সচরাচর আমরা ভাগশেষের যে সংজ্ঞা ব্যবহার করি, তাতে x % m = p হলে গাণিতিকভাবে খেয়াল করলে , 
−20 হলো ৫ এর সবথেকে বড় মাল্টিপল যেটে −১৭ থেকে ছোট তাই, −17%5 = -17 - (-20) = 3; তাই উত্তর হবে ৩ ।

এই কেসটা handle করা একটি উপায় হলো নেগেটিভ সংখ্যাটিকে (-17) একটি 5 এর মাল্টিপল এর সাথে যোগ করা যেন সংখ্যাটি (-17) থেকে বড় হয়ে যায়,তারপরে mod করা। যেমন:

 -17%5
= (-17+100)%5 ; [ 100 > -17 and 100 % 5 = 0 ]
= 83%5
= 3

 -17%5
= (-17+25)%5 ; [ 25 > -17 and 25 % 5 = 0 ] 
= 3%5
= 3

 -17%5
= (-17+35)%5 ; [ 35 > -17 and 35 % 5 = 0 ]
= 18%5
= 3

C++ আমরা −5 % 4 = −1 পাব। কিন্তু উত্তর হলো, -5 - (-8) = -5 + 8 = 3

অতএব, C++ এ মডুলো অপারেশন করার সময় একটি নেতিবাচক সংখ্যার জন্য চেক রাখা ভাল।
```c++
 res = a % m; //res = -5 % 4 = -1
 if ( res < 0 ) res += m; // res = -1 + 4 = 3 ;correct
```

```
### সুপরিচিত big mod সমস্যায়
```
সমস্যাটি হলো তোমাকে (a^b)%m এর মান বের করতে হবে। a,b,m বলে দেয়া হবে, সবগুলোর range 2^31 পর্যন্ত হতে পারে। overflow না খেয়ে মানটি বের করতে হবে। O(log₂n)এ এটা করতে পারি।
```

![image](https://user-images.githubusercontent.com/59710234/154563034-35664150-81f3-431c-bf1f-358904418081.png)

```
2^50 বের করতে 2^26 ,2^27,...,2^49 বের করার দরকার নাই। 2^25 পর্যন্ত বের করে square করে দিলেই হচ্ছে (2^25)^2। আবার 2^25 পর্যন্ত আসতে (2^12)^2 পর্যন্ত বের করে square করে ((2^12)^2)^2 সাথে ২ গুণ করে দিলেই যথেষ্ট। অতিরিক্ত ২ গুণ করছি সংখ্যাটি বিজোড় সে কারণে। প্রতি স্টেপে গুণ করার সময় mod করতে থাকবে যাতে overflow না হয়।
```
![image](https://user-images.githubusercontent.com/59710234/154576603-a5603255-ecbd-4fad-92b7-6c0e21445eb8.png)

```c++
   long long M;
   long long F(long long N,long long P){
      if(P==0) return 1;
	 if(P%2==0){
	    long long ret = F(N,P/2);
	    return ((ret%M)*(ret%M))%M;
	 }
      else return ((N%M)*(F(N,P-1)%M))%M;
   }
```

```
ভাগ করার সময় গুণ,আর যোগের মত সুত্র দুটি কাজ করেনা,এটার জন্য তোমাকে extended euclid আর modular inverse জানতে হবে।

সিপিউর জন্য mod খুব costly একটা অপারেশন। যোগ,গুণের থেকে mod করতে অনেক বেশি সময় লাগে। অপ্রয়োজনে mod ব্যবহার করলে কোড time limit exceed করতে পারে,তাই overflow হবার আশংকা না থাকলে সব জায়গায় mod করা দরকার নেই।
```

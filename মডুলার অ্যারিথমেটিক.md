
### ১০০টি বই আছে,তুমি কয়ভাবে বইগুলো সাজাতে পারবে?

```
১০০! (১০০ ফ্যাক্টরিয়াল) ভাবে সাজাতে পারবে। ১০০! ১৫৮ ডিজিটের বিশাল একটি সংখ্যা। অর্থাত ১০০! বের করে ৯৭ দিয়ে ভাগ করে ভাগশেষটা বের করাই তোমার সমস্যা।

১০০! এর মান তুমি বের করতে পারবেনা ৬৪ বিট আনসাইনড ইন্টিজার দিয়েও, এরা ২^৬৪ − ১ পর্যন্ত সংখ্যা নিয়ে কাজ করতে পারে, তাই ওভারফ্লো হবে। কিন্তু আমরা জানি 
আমাদের উত্তর কখনোই 97 এর বড় হবেনা কারণ কোনো সংখ্যাকে m দিয়ে mod করা হলে সংখ্যাটি m এর থেকে বড় হতে পারবেনা।

```
```
আমরা এ ধরণের সমস্যা সমাধান করতে সাহায্য নিবো দুটি সুত্রের :

1. (a + b) mod n = [(a mod n) + (b mod n)] mod n.
2. a*b mod n = [(a mod n)(b mod n)] mod n.

উপরের সমস্যাটিতে ২য় সুত্রটি লাগবে। তোমার বের করা দরকার ১০০!%৯৭ . অর্থাত: (১০০ x ৯৯ x ৯৮ x ....... x১)%৯৭
```
``` c++
 #include<bits/stdc++.h>
 using namespace std;
 
 int main() {
    int fact=1;
   	for(int i=1;i<=100;i++){
		  fact=((fact%97)*(i%97))%97;
    printf("%d\n",fact);
 }```
 
```
এটার আউটপুট আসবে 0। অর্থাত ১০০! % ৯৭ = 0।
```

### প্রমাণ : ১ম সুত্রটির প্রমাণ

![image](https://user-images.githubusercontent.com/59710234/154542900-1653aeee-d9d1-4843-b57f-83844c1ac1b1.png)

```
X%5 = c1
Y%5 = c2
X = 5*n1 + c1
Y = 5*n2 + c2
[যেখানে n1 আর n2 দুটি ইন্টিজার।]

এখানে 5n1 + 5n2 অবশ্যই 5 এর মাল্টিপল,তাই আমরা লিখতে পারি,
5n1 + 5n2 = 5N [ N = n1 + n2 ] এবং
c1 + c2 = C

তাহলে (১) থেকে পাচ্ছি: (5N + C) % 5

এখন পরিস্কার বোঝা যাচ্ছে যে উত্তর হলো C%5 । C কে আবার mod করতে হলো কারণ c1+c2 এর মান 5 এর থেকে বড় হতেই পারে।
```
![image](https://user-images.githubusercontent.com/59710234/154545620-482ea93e-34d1-4e02-aabc-a4403eb63b9c.png)
```
তাহলে ২ কে লিখতে পারি: (c1 + c2)%5 = C%5
```
```
NOTE :

X = 13
n1 = X/5 = 13/5 = 2
c1 = X%5 = 13%5 = 3
so, X = 5*n1 + c1 = 5*2 + 3 = 13

Y = 22
n2 = Y/5 = 22/5 = 4
c2 = Y%5 = 22%5 = 2
so, Y = 5*n2 + c2 = 5*2 + 3 = 13

5n1 + 5n2 = 5*2 + 5*4 = 10 + 20 = 30 [5 er মাল্টিপল 30 ]
N = n1 + n2 = 2 + 4 = 6
5*N = 5*6 = 30
so, 5n1 + 5n2 = 5N

c1+c2 এর মান 5 এর থেকে বড় হতেই পার । c1 = 4 < 5  and c2 = 2 < 5 । c1 + c2 = 6 > 5

(5N + C) % 5;
5N % 5 = 0
C % 5 হল উত্তর ।
```
```
তাহলে ১ম সুত্রটি প্রমাণিত হলো। তারমান যোগ করে mod করা আর আগে mod করে তারপর যোগ করে আবার mod করা একই কথা। সুবিধা হলে সংখ্যাটি কোনো স্টেপেই বেশি বড় হতে পারেনা। গুণের ক্ষেত্রেই একই সুত্র প্রযোজ্য।
```

### নেগেটিভ সংখ্যার mod নিয়ে একটু আলাদা ভাবে কাজ করতে হয়।

```
x % m = p
23%5 = 20

ভাগশেষের যে সংজ্ঞা :

m এর সব থেকে বড় মাল্টিপল, যেটা x এর থেকে ছোট (যেমন: 23%5 এর ক্ষেত্রে ৫ × ৪ = ২০ হলো ৫ এর সবথেকে বড় মাল্টিপল যেটা ২৩ এর থেকে ছোট) ; সেই সংখ্যাটিকে x থেকে বিয়োগ করলে যে সংখ্যাটি পাওয়া যায় সেটাই p । ( যেমন: 23%5 = 23 − 20 = 3 )
```
```
−17%5 মনে হয়ে  এর মান -২ | কিন্তু  কিন্তু সচরাচর আমরা ভাগশেষের যে সংজ্ঞা ব্যবহার করি, তাতে x % m = p হলে গাণিতিকভাবে খেয়াল করলে , 
−20 হলো ৫ এর সবথেকে বড় মাল্টিপল যেটে −১৭ থেকে ছোট তাই, −17%5 = -17 - (-20) = 3; তাই উত্তর হবে ৩ ।

এই কেসটা handle করা একটি উপায় হলো নেগেটিভ সংখ্যাটিকে (-17) একটি 5 এর মাল্টিপল এর সাথে যোগ করা যেন সংখ্যাটি (-17) থেকে বড় হয়ে যায়,তারপরে mod করা। যেমন:

 -17%5
= (-17+100)%5 ; [ 100 > -17 and 100 % 5 = 0 ]
= 83%5
= 3

 -17%5
= (-17+25)%5 ; [ 25 > -17 and 25 % 5 = 0 ] 
= 3%5
= 3

 -17%5
= (-17+35)%5 ; [ 35 > -17 and 35 % 5 = 0 ]
= 18%5
= 3
```
### সুপরিচিত big mod সমস্যায়
